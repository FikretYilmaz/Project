## Outline

In preparation for the Project you'll be setting up your project base, frontend and backend. This can be used as a template for any software project that will be written using `React.js` and `Node.js`, the [tech stack](https://svsg.co/how-to-choose-your-tech-stack/) you've learned about in this program. At the end of this guide your folder structure will look like this:

```
client/
server/
.eslint.json (OPTIONAL)
.gitignore
.prettierrc.json (OPTIONAL)
package-lock.json
package.json
```

- **client** - A folder that contains the source code for your frontend application (React.js)
- **server** - A folder that contains the source code for your backend application (Node.js as the server, and MySQL as the database)
- **.eslint.json** - A file that includes the configuration settings for a popular JavaScript [linter](https://medium.com/dailyjs/why-you-should-always-use-a-linter-and-or-pretty-formatter-bb5471115a76)
- **.gitignore** - A file that contains a list of file and folder names to be ignored by GIT when committing your code
- **.prettierrc.json** - A file that includes the configuration settings for a popular [code formatter](https://github.com/prettier/prettier)
- **package-lock.json** - An [autogenerated](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8) file, that keeps track of dependency installs
- **package.json** - A file that contains a list of all the metadata about the project (application name, dependencies, scripts, etc.)

Let's get started!

### First steps

1. The first step is to create a project folder. The name should reflect the application name, but for now you can keep it simple:

`class<YOUR_CLASS_NUMBER>Project`

Then, using the Command Line, navigate to that folder and start tracking any file changes with GIT:

`git init`

From now on you'll be able to always revert any mistakes you might have made.

2. The second step is to create a [package.json](https://medium.com/beginners-guide-to-mobile-web-development/why-package-json-npm-basics-cab3e8cd150) file.

When working in a team, it's better to use one package manager. This can either be **npm** or **yarn**. We will use **npm**.

Using the CLI, type in:

`npm init`

You'll get a list of questions about what your application will be about. After answering those it'll create a **package.json** file in your folder.
(Or type in `npm init -y` for generating it without having it ask any questions!)

3. The third step is to create the other files and folders (excluding `client/` for now) from the list.

Use the CLI or right-click to create a `server/` folder.

Also create a `.gitignore` file. For now just type in `node_modules` as the single folder to be ignored by GIT.

4. The fourth and last step is to create a remote repository. Create one on GitHub and link it to your local machine. Push all the files you have so far, and make sure you give it a meaningful commit message (like, `created basic project folder setup`).

### Creating our Node.js application base

Now that we've got the basics out of the way, we can get started with development! We'll get started on the backend, by writing our server code.

1. Create a `server` folder at the root of the project folder. Inside, create a file called `index.js`. This is where we will write the code to create our web server.

For sake of simplicity and faster [feature](https://www.quora.com/How-do-you-define-a-feature-of-a-software-precisely-and-effectively) development we'll use a Node.js framework called **Express.js**.

First we have to install it, which can be done through **npm**. Execute the following from the root of the folder, using the CLI:

`npm install express`

Then write the following inside `server/index.js`:

```js
// Filename: index.js
const express = require("express"); // This loads the Express functionality in

const app = express(); // This instantiates Express so we can use it

app.use(function requestHandler(request, response) {
  response.send("Hi everybody! Now it is an Express server");
});

const PORT = 8080;

app.listen(PORT, () =>
  console.log(
    "This message makes visible to the developer that the server is running, usually you want to include the port number here as well (for debugging purposes)"
  )
); // The listen() function starts the Express server, by making it actively listen (to port 8080)
```

2. Let's change the code to send the message to everyone who accesses our page from the root route, `'/'`. This will be `http://localhost:8080/` and generate 404 error for all other requests.

Replace

```js
app.use(function requestHandler(request, response) {
  response.send(
    "Hi everybody! This response gets sent with every client request"
  );
});
```

with

```js
app.get("/", function requestHandler(request, response) {
  response.send(
    "Hi everybody! This response only gets send when the client is at the root (/) of the page"
  );
});
```

Restart your server with `node server/index.js`. Then visit the following two different urls: `http://localhost:8080/` and `http://localhost:8080/randomnameforroute`. Only the root page (index) will show us the response message. All other requests will end up with 404 [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).

> **Note** - in order to avoid restarting server manually every time we change the source code, we can use [nodemon](https://nodemon.io/) package. You can install it globally and use it instead of the `node` command when executing a Node.js file.
> `npm install --global nodemon`.
> Now you can use `nodemon server/index.js` to run and watch your Node.js files.

3. Now we can "teach" our server to handle different URLs and [HTTP methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) which together construct routes.

> _Routing_ refers to determining how an application responds to a client request to a particular endpoint (like `app.get("/")`). Each route can have one or more handler functions (that are callbacks), which are executed when the route is matched. For example, if a user goes to `http://somewebsite.com/` then the GET endpoint for `/` will be triggered and the route (all the request handler functions inside) will be executed.

```js
app.get("/", function requestHandler(request, response) {
  response.send("Going to http://somewebsite.com/ and this is the response!");
});
```

Route definition takes the following structure:

```js
router.METHOD(PATH, HANDLER, [HANDLER2, [HANDLER3,...]])

// For example:
app.get('/', function (req, res) {
  res.send('This response gets send to the client the moment they request for URL http://localhost:8080/');
})
```

Routers can be nested. You can define router as a handler:

```js
const apiRouter = express().Router();

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/ path");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add path");
});

app.use("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});
```

The code above will create 3 routes which can be triggered by the user that visits them from the browser. Any other route will generate `404` error (this is automatic behavior by Express).

```
GET /api
POST /api/add
GET /
```

> **Note 1** - The order is important. Routes defined first will trigger and be executed when it's a match.
>
> **Note 2** - Once a route handler is triggered, it will not proceed to another matching route handler, unless you use **next()** function. Next function is being provided as 3rd argument to handler functions, but it is optional and can therefore be left if not needed.
>
> ```js
> app.use("*", function logGetRequests(req, res, next) {
>   // if this is first declared route - you will see the following message on every GET request
>   console.log("someone made a request with GET method");
>   next(); // this function will pass execution to next matching route handler
> });
> ```
>
> **Note 3** - to understand better how Express works and the order of execution of your handlers it's advised to read more about [writing](https://expressjs.com/en/guide/writing-middleware.html) and [using](https://expressjs.com/en/guide/using-middleware.html) middleware functions.

> **Note** - A middleware is a function that modifies the `req` or `request` object with

### Recap Node base app

Let's recap how our `server/index.js` file content might look like:

```js
const express = require("express");

const app = express();

const apiRouter = express.Router();

app.use("*", function logGetRequests(req, res, next) {
  console.log("Someone made a request with the GET method");
  next();
});

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add");
});

app.use("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});

const PORT = 8080;

app.listen(PORT, function() {
  console.log(`The server is running on port ${PORT}`);
});
```

If you open the `http://localhost:8080/` URL in the browser, you will see the `index page, triggered by GET /` message in the browser and `someone made a request with GET method` message in the CLI (which is where server-side messages are displayed).

You can now also access following routes:

- GET `http://localhost:8080/api/`
- POST `http://localhost:8080/api/add`

### Creating our base React app

There are multiple ways of setting up a React environment, but for this project we'll be using `create-react-app`. Make sure you have installed it to your machine globally.

> **Note**: You can install `create-react-app` globally by using the following command in the CLI: `npm install -g create-react-app`

1. Make sure you are in the root of your project folder. Then execute the following command through the CLI: `create-react-app client`. This will create a `client/` folder in your project, including a basic React setup inside.

This might be a good moment for another GIT commit. Make the message meaningful!

2. The next step is to create a proxy from the frontend to the backend. What this means is that whenever the frontend makes an API call to your backend API it will do so without you explicitly having to specify this. Let's write some code to make this concrete.

We'll be using the `http-proxy-middleware` for more accurate [proxying](https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development).

Inside the root of your React folder run the command `npm install http-proxy-middleware`.

Then create a file, also at root, called `setupProxy.js` and paste in the following code:

```js
const proxy = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(proxy('/api', { target: 'http://localhost:8080/' }));
};
```

`Create-react-app` will automatically recognize this file and the code inside.

That's it for the frontend for now. In the coming weeks we'll build on this.

### Running frontend and backend simultaneously

Now that we've finished both the basic setup for frontend and backend we can think about workflows. In order to run both parts of the application we can use the package `concurrently`.

From the root of the project folder run the command `npm install concurrently`. This package allows you to run multiple npm scripts simultaneously.

Next, add inside the `package.json` at the root of the project folder the following code in the `scripts` object:

```json
"scripts": 
{
  "client": "npm start --prefix client",
  "server": "nodemon server/index.js",
  "start": "concurrently \"npm run server\" \"npm run client\"",
}
```

Now when you run `npm start` through the Command Line both your frontend and backend will startup!

### Splitting your application code: folder organization

Although we can write all the code in one file, it will eventually become big, complex and unclear.

To get a better overview we can **split** the code into separate smaller files. Each file will then be responsible for providing the application a different functionality.

We will change the folder structure of `server/` into the following:

```
server/
	api/
		index.js - Contains all our routes and necessary logic
	app.js - Contains all our middlewares
	index.js - Contains the code that starts and runs our HTTP server
```

```js
// Path: server/index.js
// Purpose of file: To start our HTTP server
const app = require("./app"); // This loads in the code from app.js

const PORT = 8080;
app.listen(PORT, function() {
  console.log(`The server is is running on port ${PORT}`);
}); // We can use that "app" functionality now in this file to start the server
```

```js
// Path: server/app.js
// Purpose of file: To initialize Express and create basic endpoints
const express = require("express"); // Loading in Express functionality

const apiRouter = require("./api"); // Loading in our custom index.js from /api (it will automatically look for index.js)

const app = express(); // Creating an Express instance

app.use("*", function logGetRequests(req, res, next) {
  console.log("someone made a request with GET method");
  next();
});

app.get("/api", apiRouter);

app.get("/", function(req, res) {
  res.send("index page, triggered by GET /");
});

module.exports = app;
```

```js
// Path: server/api/index.js
// Purpose of file: To contain all our routes and necessary logic
const apiRouter = require("express").Router();

apiRouter.get("/", function(req, res) {
  res.send("triggered by GET /api/ path");
});

apiRouter.post("/add", function(req, res) {
  res.send("triggered by POST /api/add path");
});

module.exports = apiRouter;
```

### Serving static files

When using Express, it needs to know in which folder you'll keep your static files (also known as assets).

Express provides [special middleware](https://expressjs.com/en/starter/static-files.html) which helps to serve static files requested by the client.

```js
express.static(root, [options]);
```

We can use static middleware to allow our http-server to send content of any requested static file from `root` folder.
For example, if we create `public/index.html` and `public/style.css` files we will be able to request them from browser directly. Let's try it:

Add this middleware before any route in `server/app.js`

```js
// server/app.js
const path = require("path");

app.use(express.static(path.join(__dirname, "public")));
```

> **Note** - path is a default nodejs package in older versions.

Create new `public/index.html` file

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Node App</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <h1>Home page</h1>
  </body>
</html>
```

Create new `public/style.css` file

```css
body {
  background: #f0f0f0;
  color: #444;
  font: normal 18px Arial, sans-serif;
}

h1 {
  color: red;
}
```

Now, accessing `http://localhost:8080/` will trigger static middleware to serve `public/index.html` file (if index.html file is available it gets served automatically) which will request `http://localhost:8080/style.css` (check the Network tab) and get content of `public/style.css`.

Note that our `app.get('/', ...);` route is not triggered anymore. Reason for that is, if express.static could find a file by requested name, next() function will NOT be called. If there is no such file, next() function will be executed. You can try it by accessing not existing asset, like `http://localhost:8080/app.js` and changing `app.get('/', ...);` to `app.get('*', ...);` for example. You will see "index page, triggered by GET /" message in browser.

### (OPTIONAL) Lint and format js/jsx

The following two modules are optional, but highly recommended. When writing complex applications you want to reduce the load as much as possible with which linting and formatting can help a lot. 

We'll be using [eslint](https://eslint.org/) for linting and [prettier](https://prettier.io/) for code formatting.

Eslint will help us find and fix bad code patterns.
Prettier will help autoformat your code, so that it's more readable for humans.

Both eslint and prettier have integration with most IDEs and code editors.

Run this command to install all packages needed for the `eslint` and `prettier` setup.

```
npm install --save-dev eslint eslint-config-airbnb-base eslint-config-prettier eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react prettier
```

1. Let's start with creating the eslint configuration file first. Inside the root of the project folder create a file called `.eslintrc.json`. Add the following code to it:

```json
// .eslintrc.json
{
  "extends": [
    "airbnb-base",
    "plugin:react/recommended",
    "plugin:prettier/recommended"
  ],
  "rules": {
    "prettier/prettier": "error",
    "func-names": 0,
    "react/jsx-filename-extension": [
      1,
      {
        "extensions": [".js", ".jsx"]
      }
    ]
  },
  "env": {
    "browser": true,
    "node": true,
    "jasmine": true
  },
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    }
  }
}
```

2. Next, create a file called `.prettierrc.json`. Add the following code to it:

```json
// .prettierrc.json
{
  "trailingComma": "es5",
  "tabWidth": 4,
  "semi": true,
  "singleQuote": true
}
```

Next step would be to set up your code editor. You can download eslint and prettier plugins for it. Most likely those plugins will find and use config files we just created.

### Lint files automatically before commit.

This setup will allow you work in a team with more confidence, have the same code linting and formatting for every team member, and won't allow "bad code" to go to remote repo.

To achieve this we can use [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks). The `pre-commit` hook in particular.

Let's install following packages: `husky` and `lint-staged`

With `husky` we can specify commands we want to run on git hooks.
`lint-staged` helps to perform commands only on staged files (the ones that were staged with `git add` command.

```
npm install --save-dev husky lint-staged
```

To use husky, we can add the following section in our `package.json` file:

```json
// package.json
"husky": {
    "hooks": {
        "pre-commit": "lint-staged"
    }
},
```

Similar for lint-staged:

```json
// package.json
"lint-staged": {
    "*.{js,jsx}": [
        "eslint",
        "git add"
    ]
},
```

The combination of these two code blocks will make it so that eslint will be executed on all staged files, whenever we try to commit our changes.
If eslint finds errors, the commit process will be aborted. In that case you would need to fix the problems first and then commit again.

## Conclusion

Finished? Be proud of yourself, because you just setup a basic project folder! You are now completely able to start any web application project using Node.js in the backend and React in the frontend.

Be sure to commit everything you did to your remote repository. When you're finished put a link to it in your class Slack channel, so the teacher can see it.
